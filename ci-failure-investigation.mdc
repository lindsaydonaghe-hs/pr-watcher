---
description: Apply when investigating CI failures or TypeScript errors. Ensures thorough investigation before dismissing issues as infrastructure problems.
globs:
alwaysApply: false
---

# CI Failure & Error Investigation

When investigating CI failures or errors, **do not prematurely conclude issues are unrelated to code changes**. Follow this systematic investigation approach.

## Core Principle

**Assume code changes are the cause until proven otherwise.** Infrastructure issues are real, but code issues are more common and more actionable.

## Investigation Checklist

### 1. Distinguish Error Types

- **Exit code 130/137**: Process killed (SIGINT/SIGTERM) - *may* be infrastructure, but still investigate
- **TypeScript errors (TS####)**: Almost always code-related - investigate thoroughly
- **Lint errors**: Code-related
- **Test failures**: Code-related unless flaky (check history)
- **Build errors**: Usually code-related

### 2. For TypeScript Errors

When you see TypeScript errors in files you didn't directly modify:

1. **Trace the dependency chain**: Your changes to Package A may break Package B that depends on A
2. **Check type compatibility**: Adding optional props to one type in a union can break interchangeable usage
3. **Run broader type checks**: Don't just check the modified package; check dependent packages:
   ```bash
   # Check specific project (adapt to your build system)
   yarn typecheck          # or npm run typecheck
   yarn tsc --noEmit       # direct TypeScript check
   
   # For monorepos with nx
   yarn nx affected --target=typecheck
   
   # For monorepos with turbo
   turbo run typecheck --filter=...[origin/main]
   ```

### 3. For Shared Types/Interfaces

When modifying types that are exported or shared:

1. **Search for usages**: Find where the type is imported
2. **Check for union types**: Components used interchangeably require compatible prop types
3. **Consider adding to shared base type**: If a prop is optional, adding it to a shared base type ensures compatibility

### 4. Common Patterns That Break Downstream

```typescript
// BEFORE: Compatible union
type PropsA = { name: string };
type PropsB = { name: string };
const Component = condition ? ComponentA : ComponentB; // ✅ Works

// AFTER: Incompatible union (breaks downstream)
type PropsA = { name: string; color?: string };  // Added prop
type PropsB = { name: string };  // No color prop
const Component = condition ? ComponentA : ComponentB; // ❌ TS2604

// FIX: Add to shared base or both types
type SharedProps = { name: string; color?: string };
type PropsA = SharedProps;
type PropsB = SharedProps;  // color is optional, ComponentB can ignore it
```

## Red Flags That Suggest Code Issues

- Error mentions files in packages that depend on your changes
- TypeScript errors about missing properties or incompatible types
- Errors in components that use your modified types interchangeably
- Multiple unrelated CI jobs failing with the same error pattern
- Errors started appearing after your PR was pushed

## Red Flags That Suggest Infrastructure Issues

- Exit code 130/137 with no error output
- Errors about network timeouts, disk space, memory
- Random test failures that pass on retry with no code changes
- Errors in CI setup/teardown, not in actual build/test steps
- Same errors happening on unrelated PRs at the same time

## Before Concluding "Not Our Code"

1. ✅ Searched for usages of modified types/interfaces
2. ✅ Ran type checks on dependent packages (not just modified package)
3. ✅ Checked if error files import from packages you modified
4. ✅ Verified the error existed before your changes (check main branch)
5. ✅ Read the actual error message carefully, not just the exit code
6. ✅ Checked if other PRs are seeing the same failure
7. ✅ **Actually followed your own rules** - if you wrote a rule about running `tsc -b`, did you run it?

## Meta-Rule: Follow Your Own Advice

If you've created or know about a rule for catching errors (like using `tsc -b` instead of `tsc --noEmit`), you MUST actually follow it. Writing a rule and then not following it is worse than not having the rule at all.

## Reading CI Logs Properly

### Don't Skim - Read the FULL Output

When using `bklog` or viewing CI logs:

1. **Look for truncation indicators**: Output may contain `——` or similar separators indicating truncated sections
2. **The real error is often in the middle**: Don't just read beginning and end, then conclude "exit 130 = infrastructure"
3. **Search for actual error patterns**: Look for `error TS`, `Error:`, `FAILED`, etc.
4. **Read the compiler output, not just exit codes**: Exit code 130 with TypeScript errors is a CODE issue, not infrastructure

### Exit Code 130 is NOT Automatically Infrastructure

```
❌ WRONG thinking:
"Exit status 130... must be infrastructure issue"

✅ CORRECT thinking:
"Exit status 130... let me find what error caused the process to be killed"
```

Exit code 130 means the process was interrupted. This happens when:
- **Infrastructure**: Runner killed the job (timeout, OOM)
- **Code issue**: Build failed and CI terminated the process

**How to tell the difference**: Look for actual error output BEFORE the exit code.

### Repeated Failures = Probably Code

If the same CI job keeps failing across multiple commits:

- ❌ Don't keep saying "infrastructure issue" each time
- ✅ The repeated pattern strongly suggests a real code problem
- ✅ Dig deeper into the logs each time until you find the root cause

## Using with PR Watcher

When PR Watcher reports CI failures:

1. Use `bklog <URL>` to get the full error details
2. **Read the ENTIRE output**, not just the summary
3. **Look for truncated sections** and expand them
4. Apply this investigation checklist before dismissing as non-blocking
5. If truly infrastructure-related, add pattern to `NON_BLOCKING_CI` env var
